"""This script inputs the PGN file generated by lichess_evals_extractor.py and outputs a JSON file
containing the following columns:
- White, Black, WhiteElo, BlackElo, WhiteResult, BlackResult, gi, gpl, acpl, white_move_number, black_move_number
"""

import json
import os
import chess.pgn
import random
import time
import math
from chess.engine import Cp, Mate, MateGiven, Wdl
import chess.engine

# Function to calculate the expected value of a position based on the scoring system
def calculate_expected_value(win_prob, draw_prob, loss_prob, turn, scoring_system):
    if scoring_system == "Standard":
        if turn == "White":
            expected_value_white = win_prob * 1 + draw_prob * 0.5
            expected_value_black = loss_prob * 1 + draw_prob * 0.5
        else:
            expected_value_white = loss_prob * 1 + draw_prob * 0.5
            expected_value_black = win_prob * 1 + draw_prob * 0.5
    else:  # NorwayChess
        if turn == "White":
            expected_value_white = win_prob * 3 + draw_prob * 1.25
            expected_value_black = loss_prob * 3 + draw_prob * 1.25
        else:
            expected_value_white = loss_prob * 3 + draw_prob * 1.25
            expected_value_black = win_prob * 3 + draw_prob * 1.25
    return expected_value_white, expected_value_black

# Function to extract %eval from comments
def extract_eval_from_node(node):
    if node.eval():
        eval_value = node.eval().relative
        if eval_value.is_mate():
            return 10 if eval_value.mate() > 0 else -10
        else:
            return eval_value.score() / 100.0
    else:
        return None

# Function to classify blunders, mistakes, inaccuracies
def blunder_mistake_inaccuracy(exp_point_loss, is_white, counts, scoring_system):
    if scoring_system == "NorwayChess":
        blunder_threshold, mistake_threshold = 1.25, 0.625
    else:  # Standard
        blunder_threshold, mistake_threshold = 0.4, 0.2

    if exp_point_loss >= blunder_threshold:
        key = 'white_blunder' if is_white else 'black_blunder'
    elif exp_point_loss >= mistake_threshold:
        key = 'white_mistake' if is_white else 'black_mistake'
    else:
        key = 'white_inaccuracy' if is_white else 'black_inaccuracy'
    counts[key] += 1

    return counts

def calculate_gi(game, scoring_system):
    node = game
    white_gpl = black_gpl = white_tcpl = black_tcpl = 0
    white_move_number = black_move_number = 0
    counts = {
        "white_blunder": 0, "black_blunder": 0,
        "white_mistake": 0, "black_mistake": 0,
        "white_inaccuracy": 0, "black_inaccuracy": 0
    }
    while not node.is_end():
        premove_eval = extract_eval_from_node(node)
        # Set the first move variable
        first_move = False
        if premove_eval is None:
            # Evaluation of the initial position
            premove_eval = Cp(30)
            first_move = True
        else:
            premove_eval = Cp(int(100*premove_eval))
        win_draw_loss = premove_eval.wdl()
        # print("premove: win_draw_loss",win_draw_loss)
        win_prob, draw_prob, loss_prob = win_draw_loss.wins / 1000, win_draw_loss.draws / 1000, win_draw_loss.losses / 1000
        turn = "White" if node.board().turn == chess.WHITE else "Black"
        premove_exp_white, premove_exp_black = calculate_expected_value(
            win_prob, draw_prob, loss_prob, turn, scoring_system)
        # Make the move on the board
        next_node = node.variation(0)
        #print("premove_eval", premove_eval)
        node = next_node
        # Get the %eval from the comment after the move
        postmove_eval = extract_eval_from_node(node)
        if postmove_eval is not None:
            postmove_eval = Cp(int(100*postmove_eval))
            # Get the expectation for both players after making the move
            win_draw_loss = postmove_eval.wdl()
            # print("postmove: win_draw_loss",win_draw_loss)
            win_prob, draw_prob, loss_prob = win_draw_loss.wins / 1000, win_draw_loss.draws / 1000, win_draw_loss.losses / 1000
            turn = "White" if node.board().turn == chess.WHITE else "Black"
            postmove_exp_white, postmove_exp_black = calculate_expected_value(win_prob, draw_prob, loss_prob, turn, scoring_system)
            # If it's black's turn
            if node.board().turn == chess.BLACK:
                # Assuming that first move's loss is 0
                if first_move is True:
                    exp_white_point_loss = 0
                    white_cp_loss = 0
                else:
                    # Define expected point loss of white's move
                    exp_white_point_loss = premove_exp_white - postmove_exp_white
                    # Define cp loss of white's move. It's plus because cp is from the perspective of the active player
                    white_cp_loss = int(str(premove_eval))+int(str(postmove_eval))
                # print("white_move_number white_cp_loss: ", white_move_number +1, white_cp_loss)
                # Update white's GPL
                white_gpl += exp_white_point_loss
                # Update white's tcpl
                white_tcpl += white_cp_loss
                # Add blunder, mistake, inaccuracy
                # Update counts with the new function
                counts = blunder_mistake_inaccuracy(exp_white_point_loss, 'white', counts, scoring_system)
                # Update white's move number
                white_move_number += 1
            else:
                # Define expected point loss of black's move
                exp_black_point_loss = premove_exp_black - postmove_exp_black
                # Define cp loss of black's move. It's plus because cp is from the perspective of the active player
                black_cp_loss = int(str(premove_eval))+int(str(postmove_eval))
                # Update black's GPL
                black_gpl += exp_black_point_loss
                # Update black's tcpl
                black_tcpl += black_cp_loss
                # Update counts with the new function
                counts = blunder_mistake_inaccuracy(exp_black_point_loss, 'black', counts, scoring_system)
                # Update black's move number
                black_move_number += 1
        # Check if the game has a result
        if 'Result' in game.headers and game.headers['Result'] != '*':
            # Get the result of the game
            result = game.headers['Result']
            # If white won
            if result == '1-0':
                # Calculate GI for both players
                if scoring_system == "NorwayChess":
                    white_gi = 3 - white_gpl
                    black_gi = -black_gpl
                # If the scoring system is "Standard"
                else:
                    white_gi = 1 - white_gpl
                    black_gi = -black_gpl
            # If black won
            elif result == '0-1':
                # Calculate GI for both players
                if scoring_system == "NorwayChess":
                    black_gi = 3 - black_gpl
                    white_gi = -white_gpl
                # If the scoring system is "Standard"
                else:
                    black_gi = 1 - black_gpl
                    white_gi = -white_gpl
            elif result == '1/2-1/2':
                # If it's a draw, calculate GI for both players
                if scoring_system == "NorwayChess":
                    white_gi = 1.25 - white_gpl
                    black_gi = 1.25 - black_gpl
                # If the scoring system is "Standard"
                else:
                    white_gi = 0.5 - white_gpl
                    black_gi = 0.5 - black_gpl
        else:
            # Calculate (expected) GI for both players
            white_gi = postmove_exp_white - white_gpl
            black_gi = postmove_exp_black - black_gpl

    # Calculate average GPL and ACPL
    white_avg_gpl = white_gpl / white_move_number if white_move_number != 0 else 0
    black_avg_gpl = black_gpl / black_move_number if black_move_number != 0 else 0
    white_acpl = white_tcpl / white_move_number if white_move_number != 0 else 0
    black_acpl = black_tcpl / black_move_number if black_move_number != 0 else 0

    # Extract game details
    Result = game.headers.get("Result", None)
    if Result == '1-0':
        whiteResult = 1
        blackResult = 0
    elif Result == '0-1':
        whiteResult = 0
        blackResult = 1
    elif Result == '1/2-1/2':
        whiteResult = 0.5
        blackResult = 0.5
    else:
        whiteResult = '...'
        blackResult = '...'
    # Create a dictionary with the data to be saved
    
    date = None
    if "UTCDate" in game.headers:
        dates = game.headers["UTCDate"]
    elif "Date" in game.headers:
        dates = game.headers["Date"]

    # Further game details
    game_details = {
        "White": game.headers.get("White", None),
        "Black": game.headers.get("Black", None),
        "Event": game.headers.get("Event", None),
        "Site": game.headers.get("Site", None),
        "Round": game.headers.get("Round", None),
        "WhiteElo": game.headers.get("WhiteElo", None),
        "BlackElo": game.headers.get("BlackElo", None),
        "WhiteResult": whiteResult,
        "BlackResult": blackResult,
        "Date": dates,
            }
    # Return the dictionary with the data
    return {
        "white_gi": round(white_gi, 4), "black_gi": round(black_gi, 4),
        "white_gpl": round(white_gpl, 4), "black_gpl": round(black_gpl, 4),
        "white_acpl": round(white_acpl, 4), "black_acpl": round(black_acpl, 4),
        "white_avg_gpl": round(white_avg_gpl, 4), "black_avg_gpl": round(black_avg_gpl, 4),
        "white_tcpl": white_tcpl, "black_tcpl": black_tcpl,
        "white_move_number": white_move_number, "black_move_number": black_move_number,
        **game_details,
        "counts": counts,
    }

# Main function to process PGN files and output a single JSON file
def main():
    folder = 'input_path'
    output_json = os.path.join(folder, 'aggregated_game_data.json')
    aggregated_data = {}
    scoring_system = 'Standard'  # Or 'NorwayChess' 3-1-0 scoring

    key_counter = 1
    for dirpath, dirnames, filenames in os.walk(folder):
        for filename in filenames:
            if filename.endswith('.pgn'):
                pgn_file_path = os.path.join(dirpath, filename)
                with open(pgn_file_path) as pgn:
                    while True:
                        game = chess.pgn.read_game(pgn)
                        if game is None:
                            break
                        key = key_counter
                        game_data = calculate_gi(game, scoring_system)
                        aggregated_data[key] = game_data
                        key_counter += 1

    with open(output_json, 'w') as outfile:
        json.dump(aggregated_data, outfile, indent=4)

    print(f"Aggregated data saved to {output_json}")

if __name__ == "__main__":
    start_time = time.time()
    main()
    end_time = time.time()
    print("Script finished in {:.2f} minutes".format((end_time - start_time) / 60.0))